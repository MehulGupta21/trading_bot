<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Trading Analysis</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TradingView Widget -->
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            color: #e5e7eb;
        }
        .chart-container {
            position: relative;
            height: 60vh;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        /* Loading Spinner */
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: #4f46e5;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        .mini-loader {
            width: 20px;
            height: 20px;
            border: 3px solid #6b7280;
            border-bottom-color: #e5e7eb;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-white flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 mr-3 text-indigo-400" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" /></svg>
                AI Trading Analysis
            </h1>
            <p class="text-md text-gray-400 mt-2">Professional charting powered by TradingView, with AI-driven insights.</p>
        </header>

        <div class="mb-8 flex flex-col sm:flex-row gap-3 items-center justify-center">
            <input id="ticker-input" type="text" placeholder="e.g., BTC, ETH, SOL" class="w-full sm:w-60 bg-gray-800 border border-gray-600 text-white placeholder-gray-400 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block p-3 transition">
            <button id="analyze-btn" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" /></svg>
                Analyze
            </button>
        </div>
        
        <div id="results-container" class="hidden">
            <div id="data-source-notice" class="bg-blue-900/50 border border-blue-700 text-blue-300 text-sm rounded-lg p-3 mb-4 text-center"></div>
             <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <div class="lg:col-span-3 bg-gray-800/50 rounded-xl p-2 md:p-4 shadow-2xl shadow-black/30">
                     <div class="chart-container" id="tradingview-widget-container">
                        <!-- TradingView Widget will be injected here -->
                     </div>
                </div>

                <div class="lg:col-span-2 space-y-8">
                    <div class="bg-gray-800/50 rounded-xl p-6 shadow-2xl shadow-black/30">
                        <h2 class="text-2xl font-bold text-white mb-4">Trading Tips (EMA Crossover)</h2>
                        <div id="tips-container">
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg mb-4">
                                <p class="text-sm text-gray-400 mb-1">Latest Signal</p>
                                <p id="latest-tip" class="text-xl font-bold">N/A</p>
                            </div>
                            <h3 class="text-lg font-semibold text-white mb-2">Tips Log</h3>
                            <div id="tips-log" class="max-h-40 overflow-y-auto space-y-2 pr-2">
                                <p class="text-gray-500 text-sm">No signals generated yet.</p>
                            </div>
                        </div>
                    </div>

                    <div class="bg-gray-800/50 rounded-xl p-6 shadow-2xl shadow-black/30">
                        <h2 class="text-2xl font-bold text-white mb-4">AI Technical Analysis</h2>
                        <div class="text-gray-300 prose prose-invert max-w-none space-y-4">
                            <div id="ai-analysis-text"></div>
                            <div>
                                <h3 class="font-semibold text-indigo-400">AI Forecast:</h3>
                                <p id="ai-forecast-text"></p>
                            </div>
                        </div>
                    </div>

                    <div class="bg-gray-800/50 rounded-xl p-6 shadow-2xl shadow-black/30">
                        <h2 class="text-2xl font-bold text-white mb-4">Market Sentiment</h2>
                        <div id="ai-sentiment-container"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="initial-state" class="text-center py-16">
            <div id="loader" class="hidden mx-auto mb-4"><div class="loader"></div></div>
            <p id="status-text" class="text-gray-400">Enter a crypto symbol (e.g. BTC) to begin analysis.</p>
        </div>
        
        <footer class="mt-12 text-center text-xs text-gray-500">
            <p>Disclaimer: This tool is for informational purposes only. Charting by TradingView. AI analysis is experimental.</p>
        </footer>
    </div>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            const dom = {
                tickerInput: document.getElementById('ticker-input'),
                analyzeBtn: document.getElementById('analyze-btn'),
                resultsContainer: document.getElementById('results-container'),
                initialState: document.getElementById('initial-state'),
                loader: document.getElementById('loader'),
                statusText: document.getElementById('status-text'),
                aiAnalysisText: document.getElementById('ai-analysis-text'),
                aiForecastText: document.getElementById('ai-forecast-text'),
                aiSentimentContainer: document.getElementById('ai-sentiment-container'),
                latestTip: document.getElementById('latest-tip'),
                tipsLog: document.getElementById('tips-log'),
                dataSourceNotice: document.getElementById('data-source-notice'),
                tradingViewContainer: document.getElementById('tradingview-widget-container'),
            };
            
            // --- State Management Variables ---
            let priceHistory = [];
            let signalPollingInterval = null;
            let lastSignalState = null;

            const geminiApiKey = "AIzaSyB1mXM529mCQVgT39mkxUI-EZemuEaCfW8";
            const coinlayerApiKey = "7c229be80345fddd17b5d3a0d927ce7f";
            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${geminiApiKey}`;
            
            const analysisSchema = { type: "OBJECT", properties: { analysis_text: { type: "STRING" }, forecast_text: { type: "STRING" } }, required: ["analysis_text", "forecast_text"] };
            const sentimentSchema = { type: "OBJECT", properties: { sentiment: { type: "STRING", enum: ["Bullish", "Bearish", "Neutral"] }, summary: { type: "STRING" } }, required: ["sentiment", "summary"] };
            
            dom.analyzeBtn.addEventListener('click', handleAnalysis);
            dom.tickerInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') handleAnalysis(); });


            async function handleAnalysis() {
                if (signalPollingInterval) clearInterval(signalPollingInterval);
                lastSignalState = null;
                priceHistory = [];

                const ticker = dom.tickerInput.value.trim().toUpperCase();
                if (!ticker) return showError("Please enter a crypto symbol.");
                
                setLoadingState(true, `Loading analysis for ${ticker}...`);
                
                try {
                    // Create TradingView Widget immediately
                    createTradingViewWidget(ticker);

                    const latestPrice = await fetchCoinlayerCurrentPrice(ticker);
                    
                    if (latestPrice === null) {
                        showError(`Could not fetch data for ${ticker}. AI analysis and tips disabled.`);
                        dom.dataSourceNotice.textContent = `⚠️ Could not fetch data for "${ticker}". AI analysis and tips disabled. Check the symbol.`;
                        setLoadingState(false);
                        dom.resultsContainer.classList.remove('hidden');
                        return;
                    }
                    
                    priceHistory = generateInitialData(ticker, latestPrice);
                    dom.dataSourceNotice.textContent = `ℹ️ Chart by TradingView. AI analysis and real-time tips powered by Coinlayer data.`;

                    // Initial signal generation for the log
                    const initialSignals = generateEMASignals(priceHistory);
                    updateTipsSection(initialSignals.tipsLog, true);
                    lastSignalState = initialSignals.lastSignal;
                    
                    updateLatestSignal(priceHistory);

                    dom.resultsContainer.classList.remove('hidden');
                    setLoadingState(false);
                    
                    signalPollingInterval = setInterval(() => pollRealTimeData(ticker), 10000);

                    setAiLoadingStates();
                    const aiPrompt = `Analyze the following intraday price data for ${ticker}. Data is [timestamp, price].\n\n${JSON.stringify(priceHistory.slice(-100))}`;
                    const analysisSystemPrompt = `You are a financial technical analyst. Analyze historical price data in the context of an EMA crossover strategy (9-period vs 15-period EMA). The user is viewing a TradingView chart. Provide a concise analysis and a speculative forecast. DO NOT suggest entry or exit points as they are already calculated. Be cautious and do not give financial advice.`;
                    
                    getAiAnalysis(aiPrompt, analysisSystemPrompt)
                        .then(updateUiWithAnalysis)
                        .catch(err => {
                            console.error("AI Analysis Error:", err);
                            dom.aiAnalysisText.innerHTML = `<p class="text-red-400">Could not generate AI analysis.</p>`;
                            dom.aiForecastText.textContent = 'N/A';
                        });

                    getNewsSentiment(ticker)
                        .then(updateUiWithSentiment)
                        .catch(err => {
                            console.error("Sentiment Analysis Error:", err);
                            dom.aiSentimentContainer.innerHTML = `<p class="text-red-400">Could not fetch market sentiment.</p>`;
                        });

                } catch (error) {
                    console.error("Analysis Error:", error);
                    showError(error.message);
                    setLoadingState(false);
                }
            }
            
            function createTradingViewWidget(symbol) {
                dom.tradingViewContainer.innerHTML = '';
                new TradingView.widget({
                    "autosize": true,
                    "symbol": `COINBASE:${symbol}USD`,
                    "interval": "15",
                    "timezone": "Etc/UTC",
                    "theme": "dark",
                    "style": "1",
                    "locale": "en",
                    "enable_publishing": false,
                    "hide_side_toolbar": false,
                    "allow_symbol_change": true,
                    "studies": [
                        { "id": "MAExp@tv-basicstudies", "inputs": { "length": 9 }, "styles": { "plot": { "color": "#2962FF" } } }, // Blue
                        { "id": "MAExp@tv-basicstudies", "inputs": { "length": 15 }, "styles": { "plot": { "color": "#F44336" } } } // Red
                    ],
                    "container_id": "tradingview-widget-container"
                });
            }

            async function pollRealTimeData(ticker) {
                const currentPrice = await fetchCoinlayerCurrentPrice(ticker);
                if (currentPrice === null) return; // Fetch failed, skip this tick

                priceHistory.push([Date.now(), currentPrice]);
                if (priceHistory.length > 300) { // Keep history from getting too long
                    priceHistory.shift();
                }
                
                updateLatestSignal(priceHistory, currentPrice);
            }
            
            function updateLatestSignal(data, currentPrice) {
                const price = currentPrice || data[data.length - 1][1];
                const latestSignal = getLatestSignalState(data);
                if(!latestSignal) return;

                dom.latestTip.textContent = `${latestSignal} @ $${price.toFixed(4)}`;
                dom.latestTip.className = `text-xl font-bold ${latestSignal === 'BUY' ? 'text-green-400' : 'text-red-400'}`;

                if (lastSignalState !== null && latestSignal !== lastSignalState) {
                    addSignalToLog({
                        type: latestSignal,
                        price: price,
                        date: new Date()
                    });
                }
                lastSignalState = latestSignal;
            }

            function addSignalToLog(tip) {
                 const logEntry = document.createElement('div');
                 logEntry.className = `p-2 bg-gray-900/50 rounded-md border-l-4 ${tip.type === 'BUY' ? 'border-green-500' : 'border-red-500'}`;
                 logEntry.innerHTML = `
                        <div class="flex justify-between items-center">
                            <span class="font-bold ${tip.type === 'BUY' ? 'text-green-400' : 'text-red-400'}">${tip.type}</span>
                            <span class="font-mono text-white">$${tip.price.toFixed(4)}</span>
                        </div>
                        <p class="text-xs text-gray-400">${tip.date.toLocaleString()}</p>
                 `;
                 const firstChild = dom.tipsLog.firstChild;
                 dom.tipsLog.insertBefore(logEntry, firstChild);
            }

            async function fetchCoinlayerCurrentPrice(ticker) {
                // Using a CORS proxy to bypass browser restrictions
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const apiUrl = `http://api.coinlayer.com/api/live?access_key=${coinlayerApiKey}&symbols=${ticker}`;
                try {
                    const response = await fetch(proxyUrl + encodeURIComponent(apiUrl));
                    if (!response.ok) throw new Error(`Coinlayer API proxy responded with status: ${response.status}.`);
                    const data = await response.json();
                    if (data.success && data.rates && data.rates[ticker]) {
                        return data.rates[ticker];
                    }
                    throw new Error(data.error?.info || `Symbol "${ticker}" not found on Coinlayer.`);
                } catch(error) {
                    console.error("fetchCoinlayerCurrentPrice failed:", error.message);
                    return null;
                }
            }
            
            function generateInitialData(ticker, latestPrice) {
                const prices = [];
                const now = Date.now();
                const intervalInMillis = 5 * 60 * 1000; // 5 minute intervals
                const numInitialPoints = 200; // Enough for EMA warmup
                let price = latestPrice;

                const futurePrices = [[now, price]];
                for (let i = 1; i < numInitialPoints; i++) {
                    price /= (1 + (Math.random() - 0.5) * 0.005); // reverse walk
                    const timestamp = now - (i * intervalInMillis);
                    futurePrices.push([timestamp, price]);
                }
                return futurePrices.reverse();
            }


            function setAiLoadingStates() {
                 dom.aiAnalysisText.innerHTML = `<div class="flex items-center gap-2 text-gray-400"><div class="loader mini-loader"></div><p>Generating technical analysis...</p></div>`;
                 dom.aiForecastText.textContent = '';
                 dom.aiSentimentContainer.innerHTML = `<div class="flex items-center gap-2 text-gray-400"><div class="loader mini-loader"></div><p>Analyzing latest news...</p></div>`;
            }

            function setLoadingState(isLoading, message = '') {
                dom.initialState.classList.toggle('hidden', !isLoading);
                dom.loader.classList.toggle('hidden', !isLoading);
                if (isLoading) {
                    dom.statusText.textContent = message;
                    dom.resultsContainer.classList.add('hidden');
                    dom.analyzeBtn.disabled = true;
                    dom.analyzeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    dom.analyzeBtn.disabled = false;
                    dom.analyzeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }

            function showError(message) {
                if (signalPollingInterval) clearInterval(signalPollingInterval);
                dom.resultsContainer.classList.add('hidden');
                dom.initialState.classList.remove('hidden');
                dom.loader.classList.add('hidden');
                dom.statusText.textContent = `Error: ${message}`;
            }

            function calculateEMA(prices, period) {
                if (!prices || prices.length < period) return [];
                const k = 2 / (period + 1);
                let emaArray = new Array(prices.length).fill(null);
                let initialSum = 0;
                for (let i = 0; i < period; i++) { initialSum += prices[i]; }
                emaArray[period - 1] = initialSum / period;
                for (let i = period; i < prices.length; i++) {
                    emaArray[i] = prices[i] * k + emaArray[i - 1] * (1 - k);
                }
                return emaArray;
            }
            
            function getLatestSignalState(data) {
                const prices = data.map(p => p[1]);
                if (prices.length < 15) return null;

                const ema9 = calculateEMA(prices, 9);
                const ema15 = calculateEMA(prices, 15);

                const lastEma9 = ema9[ema9.length - 1];
                const lastEma15 = ema15[ema15.length - 1];

                if (lastEma9 > lastEma15) return 'BUY';
                if (lastEma15 > lastEma9) return 'SELL';
                return lastSignalState; // No change
            }

            function generateEMASignals(data) {
                const prices = data.map(p => p[1]);
                const ema9 = calculateEMA(prices, 9);
                const ema15 = calculateEMA(prices, 15);
                const tipsLog = [];
                let lastSignal = null;

                for (let i = 15; i < data.length; i++) {
                    if (ema9[i-1] === null || ema15[i-1] === null || ema9[i] === null || ema15[i] === null) continue;

                    let currentSignal = null;
                    if (ema9[i-1] <= ema15[i-1] && ema9[i] > ema15[i]) currentSignal = 'BUY';
                    if (ema9[i-1] >= ema15[i-1] && ema9[i] < ema15[i]) currentSignal = 'SELL';

                    if(currentSignal && currentSignal !== lastSignal) {
                        tipsLog.push({ type: currentSignal, price: data[i][1], date: new Date(data[i][0])});
                        lastSignal = currentSignal;
                    }
                }
                return { tipsLog, lastSignal };
            }

            function updateTipsSection(log, reset = false) {
                 if (reset) {
                    dom.tipsLog.innerHTML = '';
                }
                if (!log || log.length === 0) {
                    dom.tipsLog.innerHTML = '<p class="text-gray-500 text-sm">No crossover signals in historical data.</p>';
                    return;
                }
                
                log.forEach(tip => addSignalToLog(tip));
            }

            async function getAiAnalysis(prompt, systemPrompt) {
                const payload = { contents: [{ parts: [{ text: prompt }] }], systemInstruction: { parts: [{ text: systemPrompt }] }, generationConfig: { responseMimeType: "application/json", responseSchema: analysisSchema } };
                return callGeminiApi(payload);
            }

            async function getNewsSentiment(ticker) {
                const prompt = `Based on recent news headlines for "${ticker}", what is the overall market sentiment? Summarize in 2-3 sentences. Respond with ONLY a valid JSON object matching this schema: ${JSON.stringify(sentimentSchema)}.`;
                const payload = { 
                    contents: [{ parts: [{ text: prompt }] }], 
                    tools: [{ "google_search": {} }]
                };
                return callGeminiApi(payload);
            }

            async function callGeminiApi(payload) {
                let attempts = 0, delay = 1000;
                while (attempts < 3) {
                    try {
                        const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        if (response.ok) {
                            const result = await response.json();
                            let textResponse = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            if (!textResponse) throw new Error("Invalid response from Gemini API.");
                            
                            if (payload.tools && !payload.generationConfig?.responseMimeType) {
                                textResponse = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();
                            }

                            return JSON.parse(textResponse);
                        }
                        if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                            const errorBody = await response.text();
                            console.error("Gemini API Error Body:", errorBody);
                            throw new Error(`Gemini API request failed with client error: ${response.status}`);
                        }
                        attempts++;
                        if (attempts >= 3) throw new Error(`Gemini API request failed after retries with status: ${response.status}`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                    } catch (error) {
                        if (error.message.includes("client error")) throw error;
                        attempts++;
                        if (attempts >= 3) throw error;
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                    }
                }
            }
            
            function updateUiWithAnalysis(analysisData) {
                dom.aiAnalysisText.innerHTML = `<p>${analysisData.analysis_text.replace(/\n/g, '</p><p>')}</p>`;
                dom.aiForecastText.textContent = analysisData.forecast_text;
            }

            function updateUiWithSentiment(sentimentData) {
                const sentimentColors = { Bullish: 'text-green-400', Bearish: 'text-red-400', Neutral: 'text-gray-400' };
                dom.aiSentimentContainer.innerHTML = `<p class="text-lg font-semibold ${sentimentColors[sentimentData.sentiment] || ''}">${sentimentData.sentiment}</p><p class="text-gray-300 mt-2">${sentimentData.summary}</p>`;
            }

        });
    </script>
</body>
</html>

